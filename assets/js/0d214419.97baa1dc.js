"use strict";(self.webpackChunk_logto_docs=self.webpackChunk_logto_docs||[]).push([[53316],{49613:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return h}});var o=r(59496);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},s=Object.keys(e);for(o=0;o<s.length;o++)r=s[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)r=s[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var u=o.createContext({}),c=function(e){var t=o.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return o.createElement(u.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,s=e.originalType,u=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),d=c(r),h=n,g=d["".concat(u,".").concat(h)]||d[h]||l[h]||s;return r?o.createElement(g,i(i({ref:t},p),{},{components:r})):o.createElement(g,i({ref:t},p))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=r.length,i=new Array(s);i[0]=d;var a={};for(var u in t)hasOwnProperty.call(t,u)&&(a[u]=t[u]);a.originalType=e,a.mdxType="string"==typeof e?e:n,i[1]=a;for(var c=2;c<s;c++)i[c]=r[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}d.displayName="MDXCreateElement"},39703:function(e,t,r){r.r(t),r.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return h},frontMatter:function(){return a},metadata:function(){return c},toc:function(){return l}});var o=r(665),n=r(40151),s=(r(59496),r(49613)),i=["components"],a={sidebar_position:4},u="Secure your webhooks",c={unversionedId:"docs/recipes/webhooks/securing-your-webhooks",id:"version-1.x/docs/recipes/webhooks/securing-your-webhooks",title:"Secure your webhooks",description:"Added in v1.5.0",source:"@site/versioned_docs/version-1.x/docs/recipes/webhooks/securing-your-webhooks.md",sourceDirName:"docs/recipes/webhooks",slug:"/docs/recipes/webhooks/securing-your-webhooks",permalink:"/docs/recipes/webhooks/securing-your-webhooks",draft:!1,editUrl:"https://github.com/logto-io/docs/tree/master/versioned_docs/version-1.x/docs/recipes/webhooks/securing-your-webhooks.md",tags:[],version:"1.x",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Webhook request",permalink:"/docs/recipes/webhooks/webhook-request"},next:{title:"\ud83d\udd10 Role-Based Access Control (RBAC)",permalink:"/docs/recipes/rbac/"}},p={},l=[{value:"Get the signing key",id:"get-the-signing-key",level:2},{value:"Verify the signature",id:"verify-the-signature",level:2}],d={toc:l};function h(e){var t=e.components,r=(0,n.Z)(e,i);return(0,s.kt)("wrapper",(0,o.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"secure-your-webhooks"},"Secure your webhooks"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Added in v1.5.0")),(0,s.kt)("p",null,"Once your server is ready to receive webhook requests, you may want to make sure that it can handle the requests securely. Logto generates a signature for each webhook request payload, which allows you to verify that the request comes from Logto."),(0,s.kt)("h2",{id:"get-the-signing-key"},"Get the signing key"),(0,s.kt)("p",null,"You'll need to get the signing key from ",(0,s.kt)("a",{parentName:"p",href:"/docs/recipes/webhooks/configure-webhooks-in-console#secure-webhook"},"the Admin Console")," to verify the signature."),(0,s.kt)("h2",{id:"verify-the-signature"},"Verify the signature"),(0,s.kt)("p",null,"Extract the signature from the ",(0,s.kt)("inlineCode",{parentName:"p"},"logto-signature-sha-256")," header of the webhook request."),(0,s.kt)("p",null,"After that, you should generate a signature using your signing key, and the webhook request body and ensure that the result matches the signature from Logto."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Use the raw body of the webhook request for signature generation; avoid using the parsed body, as servers may preprocess it before reaching your webhook endpoint handler.")),(0,s.kt)("p",null,"Logto uses an HMAC hex digest to compute the signature."),(0,s.kt)("p",null,"Here's an example of how to verify the signature in Node.js:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},"import { createHmac } from 'node:crypto';\n\nexport const verify = (signingKey: string, rawBody: Buffer[], expectedSignature: string) => {\n  const hmac = createHmac('sha256', signingKey);\n  hmac.update(rawBody);\n  const signature = hmac.digest('hex');\n  return signature === expectedSignature;\n};\n")))}h.isMDXComponent=!0}}]);