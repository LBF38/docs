---
sidebar_label: Go Web
---

import postSignOutRedirectUriFigure from './assets/go-web-post-sign-out-redirect-uri.png';
import redirectUriFigure from './assets/go-web-redirect-uri.png';
import AppNote from './fragments/_app-note.mdx';
import ConfigurePostSignOutRedirectUri from './fragments/_configure-post-sign-out-redirect-uri.mdx';
import ConfigureRedirectUri from './fragments/_configure-redirect-uri.mdx';
import FurtherReadings from './fragments/_further-readings.md';
import GetAppSecret from './fragments/_get-app-secret.mdx';
import SignInFlowSummary from './fragments/_web-sign-in-flow-summary.mdx';

# Go Web: Integrate Logto

<AppNote type="Traditional web" />

## Add Logto SDK as a dependency

:::tip
We demonstrate the integration process of the SDK based on the <a href="https://gin-gonic.com">Gin Web Framework</a>. You can also easily integrate Logto into other web frameworks by taking the same steps.
In the following code snippets, we assume your app is running on <code>http://localhost:8080</code>.
:::

Assuming your application code looks like as below:

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.GET("/", func(ctx *gin.Context) {
		ctx.String(200, "Hello Logto!")
	})
	router.Run(":8080")
}
```

Execute in the project directory:

```bash
go get github.com/logto-io/go
```

Add the `github.com/logto-io/go/client` package to your application code:

```go
// main.go
package main

import (
	"github.com/gin-gonic/gin"
	// Add dependency
	"github.com/logto-io/go/client"
)

func main() {
	router := gin.Default()
	router.GET("/", func(c *gin.Context) {
		c.String(200, "Hello Logto!")
	})
	router.Run(":8080")
}
```

## Create storage for Logto to store user credentials

Logto stores user credentials in the `Storage`.  
For traditional web applications, we need to store the user credentials in the session of the request made by the user.  
Although Go itself does not provide an implementation of `session`, we can use the Logto SDK's `Storage` type to create a session-based `Storage` adapter.

The `Storage` type in the Logto SDK is as follows:

```go
// github.com/logto-io/client/storage.go
package client

type Storage interface {
	GetItem(key string) string
	SetItem(key, value string)
}
```

We will to implement our Storage based on [github.com/gin-contrib/sessions](https://github.com/gin-contrib/sessions).

Create a `session_storage.go` file, define a `SessionStorage` and implement the Logto SDK's `Storage` interfaces:

```go
// session_storage.go
package main

import (
	"github.com/gin-contrib/sessions"
)

type SessionStorage struct {
	session sessions.Session
}

func (storage *SessionStorage) GetItem(key string) string {
	value := storage.session.Get(key)
	if value == nil {
		return ""
	}
	return value.(string)
}

func (storage *SessionStorage) SetItem(key, value string) {
	storage.session.Set(key, value)
	storage.session.Save()
}
```

## Prepare required middlewares

Next, use the [github.com/gin-contrib/sessions](https://github.com/gin-contrib/sessions) middleware in the application:

```go
package main

import (
	"github.com/gin-contrib/sessions"
	"github.com/gin-contrib/sessions/memstore"
	"github.com/gin-gonic/gin"
	"github.com/logto-io/go/client"
)

func main() {
	router := gin.Default()

	store := memstore.NewStore([]byte("your session secret"))
	router.Use(sessions.Sessions("logto-session", store))

	router.GET("/", func(ctx *gin.Context) {
		ctx.String(200, "Hello Logto!")
	})
	router.Run(":8080")
}
```

:::note
We recommend not using cookie-based sessions, as credentials stored by Logto may exceed the cookie size limit.
In this example, we use memory-based sessions. You can use Redis, MongoDB, and other technologies in production projects to store sessions as needed.
:::

## Init LogtoClient

### Create LogtConfig

<GetAppSecret />

```go
// main.go
func main() {
	// ...
	logtoConfig := &client.LogtoConfig{
		Endpoint:           "<your-logto-endpoint>", // E.g. http://localhost:3001
		AppId:              "<your-application-id>",
		AppSecret:          "<your-application-secret>",
		PersistAccessToken: true,
	}
	// ...
}
```

The `PersistAccessToken` config indicates whether the access token needs to be stored in the session.

For the usage of the access token, please refer to [Protect Your API](https://docs.logto.io/docs/recipes/protect-your-api).

### Init LogtoClient for each user request

```go
// main.go
func main() {
	// ...

	router.GET("/", func(ctx *gin.Context) {
		// Init LogtoClient
		session := sessions.Default(ctx)
		logtoClient := client.NewLogtoClient(
			logtoConfig,
			&SessionStorage{session: session},
		)

		// Use Logto to control the content of the home page
		authState := "You are not logged in to this website. :("

		if logtoClient.IsAuthenticated() {
			authState = "You are logged in to this website! :)"
		}

		homePage := `<h1>Hello Logto</h1>` +
			"<div>" + authState + "</div>"

		ctx.Data(http.StatusOK, "text/html; charset=utf-8", []byte(homePage))
	})

	// ...
}
```

## Sign In

<SignInFlowSummary />

### Configure Redirect URI

<ConfigureRedirectUri
  figureSrc={redirectUriFigure}
  redirectUri="http://localhost:8080/sign-in-callback"
/>

### Add a route for handling sign-in requests

```go
//main.go
func main() {
	// ...

	// Add a link to perform a sign-in request on the home page
	router.GET("/", func(ctx *gin.Context) {
		// ...
		homePage := `<h1>Hello Logto</h1>` +
			"<div>" + authState + "</div>" +
			// Add link
			`<div><a href="/sign-in">Sign In</a></div>`

		ctx.Data(http.StatusOK, "text/html; charset=utf-8", []byte(homePage))
	})

	// Add a route for handling sign-in requests
	router.GET("/sign-in", func(ctx *gin.Context) {
		session := sessions.Default(ctx)
		logtoClient := client.NewLogtoClient(
			logtoConfig,
			&SessionStorage{session: session},
		)

		// The sign-in request is handled by Logto.
		// The user will be redirected to the Redirect URI on signed in.
		signInUri, err := logtoClient.SignIn("http://localhost:8080/sign-in-callback")
		if err != nil {
			ctx.String(http.StatusInternalServerError, err.Error())
			return
		}

		// Redirect the user to the Logto sign-in page.
		ctx.Redirect(http.StatusTemporaryRedirect, signInUri)
	})

	// ...
}
```

### Add a route for handling sign-in callback requests

When the user signs in successfully on the Logto sign-in page, Logto will redirect the user to the Redirect URI.

Since the Redirect URI is `http://localhost:8080/sign-in-callback`, we add the `/sign-in-callback` route to handle the callback after signing in.

```go
// main.go
func main() {
	// ...

	// Add a route for handling sign-in callback requests
	router.GET("/sign-in-callback", func(ctx *gin.Context) {
		session := sessions.Default(ctx)
		logtoClient := client.NewLogtoClient(
			logtoConfig,
			&SessionStorage{session: session},
		)

		// The sign-in callback request is handled by Logto
		err := logtoClient.HandleSignInCallback(ctx.Request)
		if err != nil {
			ctx.String(http.StatusInternalServerError, err.Error())
			return
		}

		// Jump to the page specified by the developer.
		// This example takes the user back to the home page.
		ctx.Redirect(http.StatusTemporaryRedirect, "/")
	})

	// ...
}
```

## Sign out

### Configure Post Sign-out Redirect URI

<ConfigurePostSignOutRedirectUri
  figureSrc={postSignOutRedirectUriFigure}
  postSignOutRedirectUri="http://localhost:8080"
/>

This configuration enables the user to return to the home page after signing out.

### Add a route for handling signing out requests

```go
//main.go
func main() {
	// ...

	// Add a link to perform a sign-out request on the home page
	router.GET("/", func(ctx *gin.Context) {
		// ...
		homePage := `<h1>Hello Logto</h1>` +
			"<div>" + authState + "</div>" +
			`<div><a href="/sign-in">Sign In</a></div>` +
			// Add link
			`<div><a href="/sign-out">Sign Out</a></div>`

		ctx.Data(http.StatusOK, "text/html; charset=utf-8", []byte(homePage))
	})

	// Add a route for handling signing out requests
	router.GET("/sign-out", func(ctx *gin.Context) {
		session := sessions.Default(ctx)
		logtoClient := client.NewLogtoClient(
			logtoConfig,
			&SessionStorage{session: session},
		)

		// The sign-out request is handled by Logto.
		// The user will be redirected to the Post Sign-out Redirect URI on signed out.
		signOutUri, signOutErr := logtoClient.SignOut("http://localhost:8080")

		if signOutErr != nil {
			ctx.String(http.StatusOK, signOutErr.Error())
			return
		}

		ctx.Redirect(http.StatusTemporaryRedirect, signOutUri)
	})

	// ...
}
```

After the user makes a signing-out request, Logto will clear all user credentials in the session.

## Further readings

<FurtherReadings />
